Все аргументы функций передаются по ссылке.

Функции с приставкой `!` изменяют по крайней мере один аргумент, обычно первый:
`sort!(arr)`.

Обязательные аргументы разделяются запятой и используют позиционную нотацию.

Необязательные аргументы должны иметь значения по умолчанию в сигнатуре функции, определяемые с помощью `=`.

Аргументы с ключевыми словами используют именованную нотацию и перечисляются в сигнатуре функции после точки с запятой: ``!

````
function func(req1, req2; key1=dflt1, key2=dflt2)
    # выполнить операции
end
````

Точка с запятой *не* требуется в вызове функции, принимающей аргументы в виде ключевых слов.

Оператор `return` не обязательный, но настоятельно рекомендуется.

Несколько структур данных могут быть возвращены в виде кортежа в одном операторе `return`.

Аргументы командной строки `julia script.jl arg1 arg2...`  доступны из глобальной
константы `ARGS`:
```
for arg in ARGS
    println(arg)
end
```

Анонимные функции лучше всего использовать в функциях для обработки коллекций или в генераторах списков:
`x -> x^2`.

Функции могут принимать переменное количество аргументов:

```
function func(a...)
    println(a)
end

func(1, 2, [3:5]) # tuple: (1, 2, UnitRange{Int64}[3:5])
```

Функции могут быть вложенными:

```
function outerfunction()
    # выполнить какие-либо внешние операции
    function innerfunction()
        # выполнить внутренние операции
        # может получить доступ к предыдущим внешним определениям
    end
    # выполнить дальнейшие внешние операции
end
```

Функции могут иметь явные типы возвращаемых ими значений

```
# взять любой подтип Number и вернуть его как  String
function stringifynumber(num::T)::String where T <: Number
    return "$num"
end
```

Функции можно
[векторизовать](https://docs.julialang.org/en/v1/manual/functions/#man-vectorized-1),
используя синтаксическую точку

```
# здесь мы распротраняем вычитание каждого среднего значения
# с помощью оператора `точка`
julia> using Statistics
julia> A = rand(3, 4);
julia> B = A .- mean(A, dims=1)
3×4 Array{Float64,2}:
  0.0387438     0.112224  -0.0541478   0.455245
  0.000773337   0.250006   0.0140011  -0.289532
 -0.0395171    -0.36223    0.0401467  -0.165713
julia> mean(B, dims=1)
1×4 Array{Float64,2}:
 -7.40149e-17  7.40149e-17  1.85037e-17  3.70074e-17
```

Julia создаёт 
<a class="tooltip" href="#">специализированные версии<span> Множественная диспетчеризация -
это тип полиморфизмa, заключающийся в динамическом определении, какую версию функции следует вызвать. В данном контексте динамический означает, что решение принимается при
выполнении, в то время как перегрузка методов происходит во время компиляции. Julia управляет
множественной диспетчеризацией полностью в фоновом режиме. Конечно, вы можете
обеспечить перегрузку пользовательских функций с помощью аннотаций типов.</span></a>
функций на основе типов данных. Когда функция вызывается повторно с
с теми же типами аргументов, Julia может снова использовать машинный код и
пропустить процесс компиляции.

Начиная с **Julia 0.5**,  потенциальные неоднозначности допустимы, но вызов неоднозначного метода выдаёт **немедленную ошибку**.

Переполнение стека возможно, когда рекурсивные функции вложены на много уровней.
Stack overflow is possible when recursive functions nest many levels
deep. [Trampolining](https://web.archive.org/web/20140420011956/http://blog.zachallaun.com/post/jumping-julia) 
[Трамплинг](https://web.archive.org/web/20140420011956/http://blog.zachallaun.com/post/jumping-julia) может быть использован для оптимизации хвостовых вызовов, так как Julia [пока](https://github.com/JuliaLang/julia/issues/4964) не делает этого
автоматически. В качестве альтернативы, вы можете переписать хвостовую рекурсию как итерацию.
