В языке Julia нет классов и поэтому нет конкретных для класса методов.

Типы подобны классам без методов.

Абстрактные типы могут быть подтипизированы, но не инстанцированы.

Конкретные типы не могут быть подтипизированы.

По умолчанию, структуры `struct` являются неизменяемыми.

Неизменяемые типы повышают производительность и являются потоко-безопасными, поскольку
разные потоки могут их использовать совместно без необходимости синхронизации.

Объекты, которые могут быть одним из множества типов, называются типами `Union`.

|                          |                                                   |
| ------------------------ | ------------------------------------------------- |
| Аннотация типа           | `var::TypeName`                                   |
| Декларация типа          | `struct Программист`<br>`    имя::String`<br>`    год_рождения::UInt16`<br>`    предпочитаемый_язык::AbstractString`<br>`end` |
| Декларация изменяемого типа | замените `struct` with `mutable struct`            |
| Псевдоним типа           | `const Разработчик = Программист`                         |
| Конструкторы типов       | `methods(TypeName)`                               |
| Инстанцирование типа     | `me = Programmer("Ian", 1984, "Julia")`<br>`me = Nerd("Ian", 1984, "Julia")` |
| Декларация подтипа       | `abstract type Птица end`<br>`struct Утка <: Bird`<br>`    пруд::String`<br>`end` |
| Параметрический тип      | `struct Point{T <: Real}`<br>`    x::T`<br>`    y::T`<br>`end`<br><br>`p =Point{Float64}(1,2)`<br> |
| Тип Union                | `Union{Int, String}`                              |
| Обход иерархии типов     | `supertype(TypeName)` and `subtypes(TypeName)`    |
| Супертип по умолчанию    | `Any`                                             |
| Все поля                 | `fieldnames(TypeName)`                            |
| Типы всех полей          | `TypeName.types`                                  |

Когда тип определен с *внутренним* конструктором, стандартные *внешние*
конструкторы по умолчанию недоступны и при необходимости олжны быть определены вручную. Внутренний конструктор лучше всего использовать для проверки соответствия параметров определенным условиям (инвариантности). Очевидно, что эти инварианты
могут быть нарушены при прямом доступе к полям и их изменении, если только
тип не определен как неизменяемый. Ключевое слово `new` может быть использовано для
создания объекта того же типа.

Параметры типа инвариантны, и это означает, что `Point{Float64} <: Point{Real}` ложно, даже несмотря на то, что `Float64 <: Real`.
Кортежи (`Tuple`), с другой стороны, ковариантны: `Tuple{Float64} <: Tuple{Real}`.

Полученная с помощью [вывода типов](https://ru.wikipedia.org/wiki/Вывод_типов) 
внутреннее представление Julia можно найти с помощью `code_typed()`. Это полезно в тех
случаях, когда генерируется `Any` вместо кода для конкретного типа.
